#include <cstdio>
#include "CsvSqlWriter.h" 
#include "sqliteTable.h" // dependency on SqliteData.h -> sqlite3 - this is bad
#include "split_string.h"

struct CsvSqlite
{
    SqliteData operator()(CsvField f)
    {
        switch (f.getType())
        {
            case CSV_FIELD_TYPE_NONE:
            case CSV_FIELD_TYPE_EMPTY_TEXT:
            case CSV_FIELD_TYPE_ANY:
                return SqliteData();
            case CSV_FIELD_TYPE_TEXT:
                return SqliteData(f.getColumnIndex(), f);
            case CSV_FIELD_TYPE_INTEGRAL:
                {
                int i = atoi(f.c_str());
                return SqliteData(f.getColumnIndex(), i);
                }
            case CSV_FIELD_TYPE_REAL:
                {
                double d = atof(f.c_str());
                return SqliteData(f.getColumnIndex(), d);
                }
        }
        return SqliteData();
    }
};

CsvSqlWriter::CsvSqlWriter(CsvRewriteParams params)
    : CsvRewriter(params)
{
    m_tableName = makeTableName();
    m_colSpec = makeSqlColSpec();
}

CsvSqlWriter::CsvSqlWriter(std::string rawCsv)
    : CsvRewriter(rawCsv)
{
    m_tableName = makeTableName();
    m_colSpec = makeSqlColSpec();
}

CsvSqlWriter::~CsvSqlWriter() 
{
}

void CsvSqlWriter::writeSql(FILE *fp)
{
    // http://www.njames.co.uk/reference/csvRewrite.html#sql-output

    if (getFailed())
    {
        fprintf(stderr, "%s\n", m_params.getErr().c_str());
        return;
    }

    fprintf(fp, "/* generated by csvRewrite %s */\n", m_params.getFilename().c_str());
    fprintf(fp, "BEGIN TRANSACTION;\n");

    writeCreateTable(fp);

    size_t firstDataRow = 0;
    if (m_params.getHaveHeader())
        firstDataRow = 1;

    std::string columnList = makeSqlColumnList();

    size_t recNdx;
    for (recNdx = firstDataRow; recNdx < m_csv.numRecords(); recNdx++)
    {
        CsvRecord curRec = m_csv.getRecord(recNdx);

        std::string valueList = makeSqlValueList(curRec);

        std::string insert = "INSERT INTO ";
        insert += "\"" + m_tableName + "\" (" + columnList +") VALUES (" + valueList +");";
        fprintf(fp, "%s\n", insert.c_str());
    }

    fprintf(fp, "COMMIT TRANSACTION;\n");
}

bool CsvSqlWriter::sWriteCreates(std::string &sql)
{
    sql = "";

    if (getFailed())
    {
        fprintf(stderr, "%s\n", getLastError().c_str());
        return false;
    }

    sql += sWriteCreateTable();

    return true;
}

bool CsvSqlWriter::sWriteInserts(std::string &sql)
{
    sql = "";

    size_t firstDataRow = 0;
    if (m_params.getHaveHeader())
        firstDataRow = 1;

    std::string columnList = makeSqlColumnList();

    sql += "BEGIN TRANSACTION;\n";
    size_t recNdx;
    for (recNdx = firstDataRow; recNdx < m_csv.numRecords(); recNdx++)
    {
        sql += "INSERT INTO ";
        sql += "\"" 
               + m_tableName 
               + "\" (" + columnList +")\nVALUES\n";

        CsvRecord curRec = m_csv.getRecord(recNdx);

        std::string valueList = makeSqlValueList(curRec);

        std::string values = "(" + valueList + ");";
        sql += values + "\n";
    }

    sql += "COMMIT;\n";

    return true;
}

bool CsvSqlWriter::toTable(SqliteTable &t)
{
    bool res = true;
    size_t csNdx;

    for (csNdx = 0; csNdx < m_colSpec.size(); csNdx++)
    {
        ColumnSpec cs = m_colSpec[csNdx];
        t.addColumnSpec(cs.getParamIndex(), cs.getName());
    }

    size_t recNdx = 0;
    if (m_params.getHaveHeader())
    {
        recNdx = 1;
    }

    for (/*NB*/ ; res && recNdx < m_csv.numRecords(); recNdx++)
    {
        SqliteRecord sqlRec;
        CsvRecord csvRec = m_csv.getRecord(recNdx);
        size_t colNdx;
        for (colNdx = 0; colNdx < csvRec.size(); colNdx++)
        {
            CsvField f = csvRec[colNdx];
            SqliteData d = CsvSqlite()(f);
            sqlRec.push_back(d);
        }

        t.push_back(sqlRec);
    }

    return res;
}

/*
    return vector of (name, isInteger) pairs 
*/
std::vector<ColumnSpec> CsvSqlWriter::makeSqlColSpec()
{
    std::vector<ColumnSpec> res;

    if (!m_csv.isRectangular())
    {
        m_params.setFailed(true);
        int minF = m_csv.minFields();
        int maxF = m_csv.maxFields();
        m_params.setErr("data must be tabular to render as sql");
        return res;
    }

    size_t numCols = m_csv.maxFields(); // == csv.minFields(), we're rectanglar

    CsvRecord firstLine;
    
    if (m_csv.numRecords() > 0)
        firstLine = m_csv.getRecord(0);

    size_t i;
    for (i = 0; i < numCols; i++)
    {
        ColumnSpec newSpec;
        newSpec.setParamIndex((int)i);

        if (m_params.getHaveHeader())
        {
            newSpec.setName(/*compressString*/(firstLine.getField(i)));
        }
        else
        {
            char szColNum[BUFSIZ];
            sprintf(szColNum, "column%02ld", i);
            newSpec.setName(szColNum);
        }

        newSpec.setIsIntegral(m_csv.isColIntegral(i));
        if (!newSpec.getIsInteger())
            newSpec.setIsReal(m_csv.isColReal(i));

        res.push_back(newSpec);
    }

    return res;
}

void CsvSqlWriter::writeCreateTable(FILE *fp)
{
    fprintf(fp, "CREATE TABLE \"%s\"\n", m_tableName.c_str());
    writeColSpec(fp, false);
    fprintf(fp, ";\n");
}

std::string CsvSqlWriter::sWriteCreateTable()
{
    std::string res = "";
    res += "CREATE TABLE \"" + m_tableName + "\"\n";
    res += sWriteColSpec(false);
    res += ";\n";

    return res;
}

void CsvSqlWriter::writeColSpec(FILE *fp, bool allOneLine)
{
    fprintf(fp, "(");

    if (!allOneLine)
        fputc('\n', fp);

    size_t i;
    for (i = 0; i < m_colSpec.size(); i++)
    {
        ColumnSpec cur = m_colSpec[i];
        std::string fieldName;

        if (m_params.getHaveHeader())
        {
            fprintf(fp, "\"%s\"", cur.getName().c_str());
        }
        else
        {
            fprintf(fp, "\"column%02ld\"", i);
        }

        if (cur.getIsReal())
            fprintf(fp, " REAL");
        else if (cur.getIsInteger())
            fprintf(fp, " INTEGER");
        else
            fprintf(fp, " TEXT");

        if (i < m_colSpec.size() - 1)
            fprintf(fp, ",\n");

    }

    if (!allOneLine)
        fputc('\n', fp);

    fprintf(fp, ")");
}

std::string CsvSqlWriter::sWriteCsvOrderTableCreate()
{
    std::string res = "DROP TABLE IF EXISTS " CSV_ORDER_TABLE_NAME ";\n";
    res += "CREATE TABLE " CSV_ORDER_TABLE_NAME "(position INTEGER PRIMARY KEY, columnName TEXT);\n";

    return res;
}

std::string CsvSqlWriter::sWriteCsvOrderTableInsert()
{
    std::string res = "INSERT INTO " CSV_ORDER_TABLE_NAME "(position, columnName) VALUES \n";
    CsvRecord firstLine = m_csv.getRecord(0);

    size_t i;
    for (i = 0; i < firstLine.size(); i++)
    {
        if (i > 0)
            res += ",\n";

        char buf[BUFSIZ];
        sprintf(buf, "%ld", i);
        
        res += "(";
        res += buf;
        res += ",\"" + firstLine[i] + "\")";
    }
    res += ";\n";

    return res;
}

std::string CsvSqlWriter::sWriteColSpec(bool allOneLine)
{
    std::string res = "(";

    if (!allOneLine)
        res += "\n";

    size_t i;
    for (i = 0; i < m_colSpec.size(); i++)
    {
        ColumnSpec cur = m_colSpec[i];
        std::string fieldName;

        if (m_params.getHaveHeader())
        {
            res += "\"" + cur.getName() + "\"";
        }
        else
        {
            char buf[BUFSIZ];
            sprintf(buf, "\"column%02ld\"", i);
            res += buf;
        }

        if (cur.getIsReal())
            res += " REAL";
        else if (cur.getIsInteger())
            res += " INTEGER";
        else
            res += " TEXT";

        if (i < m_colSpec.size() - 1)
            res += ",\n";

    }

    if (!allOneLine)
        res += "\n";

    res += ")";

    return res;
}

std::string CsvSqlWriter::makeSqlColumnList()
{
    std::string res;

    size_t numCols = m_colSpec.size();
    size_t colNdx;
    for(colNdx = 0; colNdx < numCols; colNdx++)
    {
        ColumnSpec curSpec = m_colSpec[colNdx];
        res += "\"" + curSpec.getName() + "\"";
        if (colNdx < numCols - 1)
            res += ",";
    }

    return res;
}

std::string CsvSqlWriter::makeSqlValueList(CsvRecord rec)
{
    std::string res;

    if (m_colSpec.size() + m_csv.numEmptyCols() != rec.size())
    {
        res = "/* ERROR: record doesn't match column spec */";
        return res;
    }

    size_t valNdx;
    //for(valNdx = 0; valNdx < colSpecs.size(); valNdx++)
    for(valNdx = 0; valNdx < rec.size(); valNdx++)
    {
        if (m_csv.isColEmpty(valNdx))
        {
            continue;
        }

        CsvField curField = rec.getField(valNdx);
        bool isNumeric = m_csv.isColIntegral(curField.getColumnIndex()) 
                         || m_csv.isColReal(curField.getColumnIndex());

        if (valNdx > 0)
            res += ",";

        if (curField.empty())
        {
            res += "NULL";
        }
        else if (isNumeric)
        {
            res += curField;
        }
        else
        {
            std::string escapedField = curField;
            splitstring::subst(escapedField, "'", "''");
            res += "'" + escapedField + "'";
        }
    }

    return res;
}
